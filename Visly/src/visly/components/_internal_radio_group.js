// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
/* tslint:disable */
/* eslint-disable */
import React, {
  createContext,
  useContext,
  useRef,
  useState,
  useCallback,
  useEffect,
} from "react";
import {
  useEventHandlers,
  combineRef,
  useRootProps,
  exists,
  InteractionState,
  renderChildren,
} from "./_internal_utils";
import { useSpacing } from "./_internal_component_utils";
import {
  DescendantsProvider,
  useDescendant,
} from "./_internal_utils_descendants";
import { mergeHotkeys, useHotkey } from "./_internal_utils_hotkeys";
export const RadioGroupContext = createContext({
  selected: undefined,
  onSelect: () => {},
  disabled: false,
  onItemClicked: () => {},
});
export function RadioGroupRoot(props) {
  const ref = useRef();
  const { selected, onSelect = () => {} } = props;
  const { states, handlers } = useEventHandlers({
    ref,
    ...props,
  });
  const {
    style,
    className,
    testId,
    innerRef,
    values,
    reactProps,
  } = useRootProps(props, states);
  const noSelectStyles = {
    userSelect: "none",
    WebkitUserSelect: "none",
    KhtmlUserSelect: "none",
    MozUserSelect: "none",
  };
  const children = useSpacing(
    props.addSpacing,
    renderChildren(props.children, values)
  );
  const [items, setItems] = useState([]);
  const [focusedOption, setFocusedOption] = useState();
  const disabled = states.includes(InteractionState.Disabled);
  const hasSelectedValue = useRef(exists(selected));
  const hasNewFocus = useRef(false);
  const stoleFocusFromButton = useRef(false);
  const selectFocusedOption = useCallback(() => {
    const item = items.find((i) => i.index === focusedOption);

    if (exists(item) && item.value !== selected) {
      onSelect(item.value);
    }
  }, [items, onSelect, focusedOption, selected]);
  const focusPrevious = useCallback(() => {
    hasSelectedValue.current = true;
    hasNewFocus.current = true;
    setFocusedOption((cur) => {
      if (!exists(cur)) {
        return null;
      }

      let newItem = items[cur];
      let newIdx = cur;

      while ((newIdx === cur || newItem.disabled) && newIdx !== 0) {
        newItem = items[--newIdx];
      }

      return newItem.disabled ? cur : newIdx;
    });
  }, [items]);
  const focusNext = useCallback(() => {
    hasSelectedValue.current = true;
    hasNewFocus.current = true;
    setFocusedOption((cur) => {
      if (!exists(cur)) {
        return null;
      }

      let newItem = items[cur];
      let newIdx = cur;

      while (
        (newIdx === cur || newItem.disabled) &&
        newIdx !== items.length - 1
      ) {
        newItem = items[++newIdx];
      }

      return newItem.disabled ? cur : newIdx;
    });
  }, [items]);
  const focusItem = useCallback(
    (value) => {
      hasSelectedValue.current = true;
      stoleFocusFromButton.current = false;
      hasNewFocus.current = true;
      const item = items.find((i) => i.value === value);

      if (exists(item)) {
        setFocusedOption(item.index);
      }
    },
    [items]
  );
  useEffect(() => {
    if (
      exists(ref.current) &&
      document.activeElement === ref.current &&
      hasSelectedValue.current &&
      hasNewFocus.current
    ) {
      hasNewFocus.current = false;
      selectFocusedOption();
    }
  }, [focusedOption, selectFocusedOption]);
  useEffect(() => {
    const item = items.find((i) => i.value === selected);

    if (exists(item)) {
      setFocusedOption(item.index);
    }
  }, [selected, items]);
  const hotkeys = mergeHotkeys([
    useHotkey(
      {
        key: "arrowup",
        allowInput: true,
        disabled,
      },
      focusPrevious
    ),
    useHotkey(
      {
        key: "arrowleft",
        allowInput: true,
        disabled,
      },
      focusPrevious
    ),
    useHotkey(
      {
        key: "arrowdown",
        allowInput: true,
        disabled,
      },
      focusNext
    ),
    useHotkey(
      {
        key: "arrowright",
        allowInput: true,
        disabled,
      },
      focusNext
    ),
    useHotkey(
      {
        key: "space",
        allowInput: true,
        disabled,
      },
      selectFocusedOption
    ),
  ]);
  const onKeyUp = useCallback(
    (e) => {
      if (exists(handlers.onKeyUp)) {
        handlers.onKeyUp(e);
      }

      hotkeys.onKeyUp(e);
    },
    [hotkeys, handlers]
  );
  const onKeyDown = useCallback(
    (e) => {
      if (exists(handlers.onKeyDown)) {
        handlers.onKeyDown(e);
      }

      hotkeys.onKeyDown(e);
    },
    [hotkeys, handlers]
  );
  const onFocus = useCallback(
    (e) => {
      if (exists(handlers.onFocus)) {
        handlers.onFocus(e);
      }

      if (!stoleFocusFromButton.current) {
        const item = items.find((i) => i.value === selected);

        if (exists(item)) {
          setFocusedOption(item.index);
        } else {
          setFocusedOption(0);
        }
      }
    },
    [handlers, items, selected]
  );
  const onBlur = useCallback(
    (e) => {
      if (exists(handlers.onBlur)) {
        handlers.onBlur(e);
      }

      setFocusedOption(undefined);
    },
    [handlers]
  );

  const onItemClicked = () => {
    stoleFocusFromButton.current = true;
    ref.current.focus();
  };

  return (
    <div
      tabIndex={0}
      ref={combineRef(props.measureRef, combineRef(innerRef, ref))}
      data-testid={testId}
      {...reactProps}
      {...handlers}
      onKeyDown={onKeyDown}
      onKeyUp={onKeyUp}
      onFocus={onFocus}
      onBlur={onBlur}
      className={className}
      style={{ ...noSelectStyles, ...style }}
      aria-activedescendant={
        exists(focusedOption) ? `option-${focusedOption}` : null
      }
    >
      <DescendantsProvider descendants={items} setDescendants={setItems}>
        <RadioGroupContext.Provider
          value={{
            selected,
            onSelect: focusItem,
            disabled: states.includes(InteractionState.Disabled),
            focusedOption,
            onItemClicked,
          }}
        >
          {children}
        </RadioGroupContext.Provider>
      </DescendantsProvider>
    </div>
  );
}
export function RadioGroupButtonRoot(props) {
  const ref = useRef();
  const {
    selected,
    onSelect,
    disabled,
    focusedOption,
    onItemClicked,
  } = useContext(RadioGroupContext);
  const { states, handlers, setFocused } = useEventHandlers({
    ref,
    ...props,
    disabled: disabled || props.disabled,
    onClick: () => {
      onSelect(props.value);
      onItemClicked();
    },
  });
  const {
    style,
    className,
    testId,
    innerRef,
    values,
    reactProps,
  } = useRootProps(
    props,
    states,
    exists(selected) && props.value === selected
      ? [
          {
            propName: "selected",
          },
        ]
      : []
  );
  const noSelectStyles = {
    cursor: "pointer",
    userSelect: "none",
    WebkitUserSelect: "none",
    KhtmlUserSelect: "none",
    MozUserSelect: "none",
  };
  const itemDisabled = states.includes(InteractionState.Disabled);
  const index = useDescendant({
    element: ref.current,
    value: props.value,
    disabled: itemDisabled,
  });
  const isFocused = index === focusedOption;
  useEffect(() => {
    if (isFocused) {
      setFocused(true);
    } else {
      setFocused(false);
    }
  }, [isFocused, setFocused]);

  const onMouseDown = (e) => {
    e.stopPropagation();
    e.preventDefault();
  };

  return (
    <div
      id={`option-${index}`}
      tabIndex={-1}
      ref={combineRef(props.measureRef, combineRef(innerRef, ref))}
      data-testid={testId}
      {...reactProps}
      {...handlers}
      onMouseDown={onMouseDown}
      className={className}
      style={{ ...noSelectStyles, ...style }}
      aria-checked={selected === props.value}
    >
      {renderChildren(props.children, values)}
    </div>
  );
}
