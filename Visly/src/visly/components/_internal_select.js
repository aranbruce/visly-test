// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
/* tslint:disable */
/* eslint-disable */
import React, {
  createContext,
  useContext,
  useRef,
  useState,
  useEffect,
  useCallback,
} from "react";
import { createPortal } from "react-dom";
import {
  useEventHandlers,
  combineRef,
  useRootProps,
  exists,
  InteractionState,
  useRect,
  noop,
  renderChildren,
} from "./_internal_utils";
import { Popover, Alignment } from "./_internal_popover";
import { Gravity } from "./_internal_tooltip";
import { mergeHotkeys, useHotkey } from "./_internal_utils_hotkeys";
import {
  DescendantsProvider,
  useDescendant,
} from "./_internal_utils_descendants";
import { useSpacing } from "./_internal_component_utils";
export const SelectContext = createContext({
  isOpen: true,
  setIsOpen: () => {},
  buttonRef: undefined,
  targetRef: undefined,
  targetRect: undefined,
  rootClassName: undefined,
  selected: undefined,
  onSelect: () => {},
  disabled: false,
  focusedOption: undefined,
  menuRef: undefined,
  menuRect: undefined,
  addSpacing: false,
  buttonStyles: {},
  handlers: {},
  reactProps: {},
  menuHotkeys: {},
  innerRef: undefined,
  renderInline: false,
});
export function SelectOptionContainer(props) {
  const {
    isOpen,
    setIsOpen,
    targetRect,
    rootClassName,
    focusedOption,
    menuRef,
    menuHotkeys,
    renderInline,
  } = useContext(SelectContext);
  const ref = useRef(null);
  useEffect(() => {
    if (exists(ref.current)) {
      ref.current.focus();
    }
  }, [ref.current]);
  const children = useSpacing(props.addSpacing, props.children);
  const handleBlur = useCallback(() => {
    setTimeout(() => {
      setIsOpen(
        exists(ref.current) && ref.current.contains(document.activeElement)
      );
    });
  }, [setIsOpen]);

  if (renderInline) {
    return (
      <div
        ref={combineRef(props.measureRef, combineRef(ref, menuRef))}
        role="listbox"
        aria-activedescendant={`option-${focusedOption}`}
        tabIndex={-1}
        className={props.className}
        onBlur={handleBlur}
        onFocus={(e) => e.stopPropagation()}
        {...menuHotkeys}
      >
        {children}
      </div>
    );
  }

  return isOpen
    ? createPortal(
        <Popover
          targetRect={targetRect}
          popover={
            <div key={props.innerKey} className={rootClassName}>
              {exists(props.cssStyles) ? (
                <style
                  style={{
                    display: "none",
                  }}
                >
                  {props.cssStyles}
                </style>
              ) : null}
              <div
                ref={combineRef(ref, menuRef)}
                role="listbox"
                aria-activedescendant={`option-${focusedOption}`}
                tabIndex={-1}
                className={props.className}
                style={{
                  overflow: "auto",
                  ...(props.useButtonWidth
                    ? {
                        width: targetRect.width,
                      }
                    : {}),
                }}
                onBlur={handleBlur}
                onFocus={(e) => e.stopPropagation()}
                {...menuHotkeys}
              >
                {children}
              </div>
            </div>
          }
          position={{
            gravity: Gravity.Bottom,
            align: Alignment.Start,
            gravityOffset: 10,
            alignOffset: 0,
          }}
          onClose={() => setIsOpen(false)}
        />,
        document.body
      )
    : null;
}
export function SelectButton(props) {
  const {
    isOpen,
    setIsOpen,
    buttonRef,
    targetRef,
    disabled,
    buttonStyles,
    innerRef,
    testId,
    handlers,
    reactProps,
  } = useContext(SelectContext);
  const openIfClosed = useCallback(
    () => setIsOpen((prev) => (prev === false ? true : prev)),
    [setIsOpen]
  );
  const hotkeys = mergeHotkeys([
    useHotkey(
      {
        key: "arrowup",
        allowInput: true,
        disabled,
      },
      openIfClosed
    ),
    useHotkey(
      {
        key: "arrowdown",
        allowInput: true,
        disabled,
      },
      openIfClosed
    ),
    useHotkey(
      {
        key: "enter",
        allowInput: true,
        disabled,
      },
      openIfClosed
    ),
    useHotkey(
      {
        key: "space",
        allowInput: true,
        disabled,
      },
      openIfClosed
    ),
  ]);

  const onKeyUp = (e) => {
    if (exists(handlers.onKeyUp)) {
      handlers.onKeyUp(e);
    }

    hotkeys.onKeyUp(e);
  };

  const onKeyDown = (e) => {
    if (exists(handlers.onKeyDown)) {
      handlers.onKeyDown(e);
    }

    hotkeys.onKeyDown(e);
  };

  return (
    <button
      tabIndex={0}
      {...reactProps}
      {...handlers}
      onKeyDown={onKeyDown}
      onKeyUp={onKeyUp}
      data-testid={testId}
      ref={combineRef(
        props.measureRef,
        combineRef(innerRef, combineRef(buttonRef, targetRef))
      )}
      className={props.className}
      aria-haspopup="listbox"
      aria-expanded={isOpen || undefined}
      onClick={disabled ? noop : () => setIsOpen(true)}
      style={buttonStyles}
    >
      {props.children}
    </button>
  );
}
export function SelectRoot(props) {
  const buttonRef = useRef(null);
  const menuRef = useRef(null);
  const { selected, onSelect, renderInline = false } = props;
  const { states, handlers } = useEventHandlers({
    ref: buttonRef,
    ...props,
  });
  const {
    style,
    className,
    testId,
    innerRef,
    values,
    reactProps,
  } = useRootProps(props, states);
  const noSelectStyles = {
    userSelect: "none",
    WebkitUserSelect: "none",
    KhtmlUserSelect: "none",
    MozUserSelect: "none",
  };
  const [menuRect] = useRect({
    ref: menuRef,
    observe: true,
  });
  const [isOpen, setIsOpen] = useState(renderInline);
  const [items, setItems] = useState([]);
  const [focusedOption, setFocusedOption] = useState(
    renderInline ? undefined : 0
  );
  const [targetRect, targetRef] = useRect({
    observe: true,
    deps: [isOpen],
  });
  const disabled = states.includes(InteractionState.Disabled);
  const selectAndClose = useCallback(
    (value) => {
      if (exists(onSelect)) {
        onSelect(value);
      }

      setIsOpen(false);
      const item = items.find((d) => d.value === value);
      setFocusedOption(exists(item) ? item.index : null);
      buttonRef.current.focus();
    },
    [items, onSelect]
  );
  const closeWithoutSelecting = useCallback(() => {
    setIsOpen(false);
    buttonRef.current.focus();
  }, []);
  const focusPrevious = useCallback(() => {
    if (!isOpen) {
      setIsOpen(true);
    } else {
      setFocusedOption((cur) => {
        if (!exists(cur)) {
          return null;
        }

        let newItem = items[cur];
        let newIdx = cur;

        while ((newIdx === cur || newItem.disabled) && newIdx !== 0) {
          newItem = items[--newIdx];
        }

        return newItem.disabled ? cur : newIdx;
      });
    }
  }, [isOpen, items]);
  const focusNext = useCallback(() => {
    if (!isOpen) {
      setIsOpen(true);
    } else {
      setFocusedOption((cur) => {
        if (!exists(cur)) {
          return null;
        }

        let newItem = items[cur];
        let newIdx = cur;

        while (
          (newIdx === cur || newItem.disabled) &&
          newIdx !== items.length - 1
        ) {
          newItem = items[++newIdx];
        }

        return newItem.disabled ? cur : newIdx;
      });
    }
  }, [isOpen, items]);
  const selectItem = useCallback(() => {
    if (!isOpen) {
      setIsOpen(true);
    } else {
      const item = items.find((d) => d.index === focusedOption);
      selectAndClose(item.value);
    }
  }, [items, focusedOption, isOpen, selectAndClose]);
  const menuHotkeys = mergeHotkeys([
    useHotkey(
      {
        key: "arrowup",
        allowInput: true,
        disabled,
      },
      focusPrevious
    ),
    useHotkey(
      {
        key: "arrowdown",
        allowInput: true,
        disabled,
      },
      focusNext
    ),
    useHotkey(
      {
        key: "enter",
        allowInput: true,
        disabled,
      },
      selectItem
    ),
    useHotkey(
      {
        key: "escape",
        allowInput: true,
        disabled,
      },
      closeWithoutSelecting
    ),
  ]);
  useEffect(() => {
    if (exists(selected)) {
      const selectedDescendant = items.find((d) => d.value === selected);

      if (exists(selectedDescendant)) {
        setFocusedOption(selectedDescendant.index);
      }
    }
  }, [items, selected]);
  return (
    <div
      ref={props.measureRef}
      tabIndex={-1}
      className={className}
      style={{ ...noSelectStyles, ...style }}
    >
      <DescendantsProvider descendants={items} setDescendants={setItems}>
        <SelectContext.Provider
          value={{
            isOpen,
            setIsOpen,
            buttonRef,
            targetRef,
            targetRect,
            rootClassName: className,
            selected,
            onSelect: selectAndClose,
            disabled: states.includes(InteractionState.Disabled),
            focusedOption,
            menuRef,
            menuRect,
            addSpacing: props.addSpacing,
            buttonStyles: style,
            innerRef,
            testId,
            handlers,
            reactProps,
            menuHotkeys,
            renderInline,
          }}
        >
          {renderChildren(props.children, values)}
        </SelectContext.Provider>
      </DescendantsProvider>
    </div>
  );
}
export function SelectOptionRoot(props) {
  const ref = useRef();
  const {
    disabled,
    selected,
    onSelect,
    focusedOption,
    menuRect,
    menuRef,
  } = useContext(SelectContext);
  const { states, handlers, setFocused } = useEventHandlers({
    ref,
    ...props,
    disabled: disabled || props.disabled,
    onClick: () => onSelect(props.value),
  });
  const itemDisabled = states.includes(InteractionState.Disabled);
  const index = useDescendant({
    element: ref.current,
    value: props.value,
    disabled: itemDisabled,
  });
  const isSelected = exists(selected) && selected === props.value;
  const isFocused = index === focusedOption;
  const {
    style,
    className,
    testId,
    innerRef,
    values,
    reactProps,
  } = useRootProps(
    props,
    states,
    isSelected
      ? [
          {
            propName: "selected",
          },
        ]
      : []
  );
  const noSelectStyles = {
    cursor: "pointer",
    userSelect: "none",
    WebkitUserSelect: "none",
    KhtmlUserSelect: "none",
    MozUserSelect: "none",
  };
  const [optionRect] = useRect({
    ref,
  });
  const maybeScrollIntoView = useCallback(() => {
    if (exists(menuRef.current)) {
      if (optionRect.top - menuRef.current.scrollTop - menuRect.top < 0) {
        ref.current.scrollIntoView();
      } else if (
        menuRect.bottom + menuRef.current.scrollTop - optionRect.bottom <
        0
      ) {
        ref.current.scrollIntoView(false);
      }
    }
  }, [menuRef, optionRect, menuRect]);
  useEffect(() => {
    if (isFocused) {
      setFocused(true);
      maybeScrollIntoView();
    } else {
      setFocused(false);
    }
  }, [isFocused, maybeScrollIntoView, setFocused]);
  return (
    <div
      id={`option-${index}`}
      tabIndex={-1}
      ref={combineRef(props.measureRef, combineRef(innerRef, ref))}
      role="option"
      aria-selected={isSelected}
      data-testid={testId}
      {...reactProps}
      {...handlers}
      className={className}
      style={{ ...noSelectStyles, ...style }}
    >
      {renderChildren(props.children, values)}
    </div>
  );
}
